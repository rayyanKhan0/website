document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const bestScoreDisplay = document.getElementById('bestScoreDisplay');
    const startMessage = document.getElementById('startMessage');
    const gameOverMessage = document.getElementById('gameOverMessage');

    // Game dimensions
    canvas.width = 320;
    canvas.height = 480;

    // Game variables
    let birdX = 50;
    let birdY = canvas.height / 2;
    let birdWidth = 34; // Approximate dimensions of a typical Flappy Bird sprite
    let birdHeight = 24;
    let birdVelocity = 0;
    const gravity = 0.3;
    const lift = -6; // Adjusted lift for better feel

    let pipes = [];
    const pipeWidth = 52; // Width of pipe sprite
    const pipeGap = 120; // Vertical gap between pipes
    const pipeSpeed = 2;
    let pipeSpawnTimer = 0; // Counter to spawn pipes
    const pipeSpawnInterval = 90; // Spawn pipe every X frames

    let score = 0;
    let bestScore = localStorage.getItem('flappyBirdBestScore') || 0;
    let gameStarted = false;
    let gameOver = false;
    let frameCount = 0; // For animation or other frame-based logic

    // --- Images (Optional - for better visuals) ---
    // Replace with actual image paths if you have them
    // const birdImg = new Image();
    // birdImg.src = 'bird.png';
    // const pipeTopImg = new Image();
    // pipeTopImg.src = 'pipe-top.png';
    // const pipeBottomImg = new Image();
    // pipeBottomImg.src = 'pipe-bottom.png';
    // const backgroundImg = new Image();
    // backgroundImg.src = 'background.png';
    // let imagesLoaded = 0;
    // const totalImages = 0; // Set to 4 if using all images above
    // function imageLoaded() {
    //     imagesLoaded++;
    //     if (imagesLoaded === totalImages) {
    //         // Start game or enable start button only after images load
    //         console.log("All images loaded");
    //     }
    // }
    // if (totalImages > 0) {
    //    birdImg.onload = imageLoaded;
    //    pipeTopImg.onload = imageLoaded;
    //    pipeBottomImg.onload = imageLoaded;
    //    backgroundImg.onload = imageLoaded;
    // }
    // --- End Images ---

    function drawBird() {
        // if (birdImg.complete && totalImages > 0) {
        //     ctx.drawImage(birdImg, birdX, birdY, birdWidth, birdHeight);
        // } else {
            ctx.fillStyle = 'yellow';
            ctx.fillRect(birdX, birdY, birdWidth, birdHeight);
        // }
    }

    function drawPipes() {
        pipes.forEach(pipe => {
            // if (pipeTopImg.complete && pipeBottomImg.complete && totalImages > 0) {
            //     // Top pipe
            //     ctx.drawImage(pipeTopImg, pipe.x, 0, pipeWidth, pipe.topHeight);
            //     // Bottom pipe
            //     ctx.drawImage(pipeBottomImg, pipe.x, pipe.topHeight + pipeGap, pipeWidth, canvas.height - pipe.topHeight - pipeGap);
            // } else {
                ctx.fillStyle = 'green';
                // Top pipe
                ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
                // Bottom pipe
                ctx.fillRect(pipe.x, pipe.topHeight + pipeGap, pipeWidth, canvas.height - pipe.topHeight - pipeGap);
            // }
        });
    }

    function updateBird() {
        birdVelocity += gravity;
        birdY += birdVelocity;

        // Collision with top/bottom boundaries
        if (birdY + birdHeight > canvas.height) {
            birdY = canvas.height - birdHeight;
            birdVelocity = 0;
            endGame();
        }
        if (birdY < 0) {
            birdY = 0;
            birdVelocity = 0;
            // Don't necessarily end game on hitting top, let them fall
        }
    }

    function updatePipes() {
        pipeSpawnTimer++;
        if (pipeSpawnTimer >= pipeSpawnInterval) {
            pipeSpawnTimer = 0;
            const topHeight = Math.random() * (canvas.height - pipeGap - 100) + 50; // Ensure gap is playable
            pipes.push({
                x: canvas.width,
                topHeight: topHeight,
                passed: false
            });
        }

        pipes.forEach(pipe => {
            pipe.x -= pipeSpeed;
        });

        // Remove pipes that are off-screen
        pipes = pipes.filter(pipe => pipe.x + pipeWidth > 0);
    }

    function checkCollisions() {
        // Bird vs Pipes
        for (let pipe of pipes) {
            if (
                birdX < pipe.x + pipeWidth &&
                birdX + birdWidth > pipe.x &&
                (birdY < pipe.topHeight || birdY + birdHeight > pipe.topHeight + pipeGap)
            ) {
                endGame();
                return;
            }

            // Score
            if (!pipe.passed && pipe.x + pipeWidth < birdX) {
                pipe.passed = true;
                score++;
                updateScoreDisplay();
            }
        }
    }

    function updateScoreDisplay() {
        scoreDisplay.textContent = `Score: ${score}`;
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('flappyBirdBestScore', bestScore);
        }
        bestScoreDisplay.textContent = `Best: ${bestScore}`;
    }

    function resetGame() {
        birdY = canvas.height / 2;
        birdVelocity = 0;
        pipes = [];
        score = 0;
        pipeSpawnTimer = 0; // Reset spawn timer so first pipe isn't immediate
        gameOver = false;
        gameStarted = false; // Important to set this
        frameCount = 0;

        updateScoreDisplay();
        gameOverMessage.style.display = 'none';
        startMessage.style.display = 'block';
    }

    function startGame() {
        if (!gameStarted) {
            gameStarted = true;
            gameOver = false;
            startMessage.style.display = 'none';
            gameOverMessage.style.display = 'none';
            resetGameVariablesForPlay(); // Reset bird pos etc., but not score necessarily if restarting
            gameLoop();
        }
        birdVelocity = lift; // Lift on first start/tap
    }

    function resetGameVariablesForPlay() {
        birdY = canvas.height / 2;
        birdVelocity = 0;
        pipes = [];
        score = 0; // Reset score on new game start
        pipeSpawnTimer = pipeSpawnInterval - 30; // Spawn first pipe a bit sooner
        frameCount = 0;
        updateScoreDisplay();
    }

    function endGame() {
        if (!gameOver) { // Prevent multiple calls
            gameOver = true;
            gameStarted = false;
            gameOverMessage.style.display = 'block';
            // Optional: Add a sound effect here
            // You can stop the gameLoop here, or let it run to show the static end screen
        }
    }

    function gameLoop() {
        if (gameOver) {
             // Optionally draw a final static frame if needed before stopping
            drawStaticEndFrame();
            return; // Stop the loop if game is over
        }

        frameCount++;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Optional: Draw background image
        // if (backgroundImg.complete && totalImages > 0) {
        //     const bgWidth = backgroundImg.width;
        //     // Simple parallax/scrolling background
        //     const bgX = -((frameCount * 0.5) % bgWidth);
        //     ctx.drawImage(backgroundImg, bgX, 0, bgWidth, canvas.height);
        //     ctx.drawImage(backgroundImg, bgX + bgWidth, 0, bgWidth, canvas.height); // Draw a second one for seamless scroll
        // } else {
            // Default solid background (already set on canvas style, or clearRect makes it transparent to body)
        // }


        if (gameStarted) {
            updatePipes();
            updateBird();
            checkCollisions();
        }

        drawPipes();
        drawBird();

        requestAnimationFrame(gameLoop);
    }

    function drawStaticEndFrame() {
        // Redraw the scene as it was when game ended
        // This is useful if you stop the gameLoop abruptly
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // if (backgroundImg.complete && totalImages > 0) { /* ... draw background ... */ }
        drawPipes(); // Draw pipes in their final positions
        drawBird();  // Draw bird in its final position
    }

    // Event Listeners
    function handleInput() {
        if (!gameStarted && !gameOver) {
            startGame();
        } else if (gameStarted && !gameOver) {
            birdVelocity = lift;
        } else if (gameOver) {
            resetGame();
            startGame(); // Autostart after reset if they click/press space
        }
    }

    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            e.preventDefault(); // Prevent page scrolling
            handleInput();
        }
    });

    canvas.addEventListener('click', () => {
        handleInput();
    });
    // For mobile touch
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent page scrolling/zooming
        handleInput();
    });


    // Initial setup
    updateScoreDisplay(); // Show best score on load
    // Call gameLoop once to draw the initial "Start" screen elements if you want dynamic elements at start
    // For simplicity, CSS handles initial message. If you have dynamic elements before start:
    function initialDraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Draw any static background elements if not using CSS
        drawBird(); // Show the bird waiting
        // No pipes yet
        // No gameLoop called yet, it starts with startGame()
    }
    initialDraw(); // Draw bird at starting position

});
